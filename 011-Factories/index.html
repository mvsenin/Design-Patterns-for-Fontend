<!DOCTYPE html>
<html>
  <head>
    <title>Factory Method and Abstract Factory design pattern demo</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="./src/styles.css" />
  </head>

  <body>
    <div class="global-state">
        <div>
            Account: <select id="account-name" name="account-name" value="">
                <option selected value="">-- Please select account --</option>
                <option value="admin">Administrator</option>
                <option value="customer">Customer</option>
                <option value="seller">Seller</option>
            </select>
        </div>
        <!--div>
            <button id="login-button">Вход</button>
        </div-->
      <span id="output" class="italic outputStyle">Please select account</span>
    </div>
    <details class="container-lg">
      <summary>
        <b><img src="/src/hand-index-thumb.svg" height="30vh" />Factory Method and Abstract Factory design pattern summary</b>
      </summary>
      <article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto">This is demo project for <strong>Factory Method</strong> and <strong>Abstract Factory</strong> design patterns</p>
        <p dir="auto">These are <strong>Creational design patterns</strong>:</p>
        <div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">Factory Method</h1></div>
        <p>Factory Method pattern allows for the creation of objects without exposing the creation logic to the client. It involves creating a separate factory function that is responsible for creating instances of various related objects based on a specified input, creating objects while abstracting away the specifics of their creation.</p>
        <p dir="auto">Pros:</p>
        <ul dir="auto">
        <li><strong>Abstraction and Encapsulation:</strong> The factory function encapsulates the logic for creating objects based on role, abstracting away the creation details. Users of the factory don't need to worry about the intricate creation process.</li>
        <li><strong>Simplified Object Creation:</strong> The factory pattern simplifies object creation. Users only need to call a function, passing the necessary parameters, to get a fully initialized object.</li>
        <li><strong>Flexibility and Extensibility:</strong> The factory can easily accommodate changes and additions of new user roles. Adding a new role is a matter of extending the specific information and adding a function to the specificInfo object.</li>
        <li><strong>Code Reusability:</strong> The creation logic is centralized in the factory function, allowing for reusability across the application. Users can be created consistently wherever needed.</li>
        <li><strong>Enhanced Readability and Maintainability:</strong> The factory pattern improves code readability by abstracting the object creation process. It's easier to understand the intent of creating a specific type of user by calling a function with a role.</li>
        <li><strong>Error Handling:</strong> The factory can provide structured error handling, ensuring that users adhere to specific roles and fail gracefully with meaningful error messages.</li>
        </ul>
        <p dir="auto">Cons:</p>
        <ul dir="auto">
        <li><strong>Complexity for Simple Cases:</strong> For simple cases where the object creation logic is straightforward, using a factory might introduce unnecessary complexity. Direct object creation might be more appropriate for such scenarios.</li>
        <li><strong>Potential Performance Overheads:</strong> The additional function calls and lookup operations in the factory can introduce a minor performance overhead compared to direct object creation. However, in most cases, this overhead is negligible.</li>
        <li><strong>Understanding the Factory Logic:</strong> For someone unfamiliar with the factory pattern, understanding the role of each function and how the factory creates objects might take some time.</li>
        <li><strong>Dependency on External Configuration:</strong> The factory relies on external configurations (like the specificInfo object) to determine object creation. If these configurations are modified or incorrect, it can lead to unexpected behavior.</li>
        <li><strong>Potential Overuse:</strong> Overuse of the factory pattern can lead to an overly complex codebase, making it harder to understand and maintain. It's important to use the pattern judiciously and where it provides clear benefits.</li>
        </ul>
        <div class="markdown-heading" dir="auto"><h1 tabindex="-1" class="heading-element" dir="auto">Abstract Factory</h1></div>
        <p>Abstract Factory abstracts the process of object creation by defining a family of related factory methods, each responsible for creating a different type of object. These factory methods are organized within an abstract factory interface or class, and the client code uses this interface to create objects.</p>
        <p dir="auto">Pros:</p>
        <ul dir="auto">
        <li><strong>Consistency:</strong> Abstract factories patterns ensure that the objects created within a family are compatible with each other. This helps us to maintain the consistency in our application, as we can ensure that all the objects created by the factory work together.</li>
        <li><strong>Flexibility:</strong> Abstract Factory pattern allows us to switch between different families of objects by using different concrete factories. This is especially useful when we need to support multiple variations of a product or when we want to change the behavior of our application by swapping out factories at runtime.</li>
        <li><strong>Extensibility:</strong> Basically, we can add new concrete factories to support new product families without modifying existing client code. This makes the system more extensible, allowing for the easy addition of new features or components.</li>
        <li><strong>Testability:</strong> Abstract factories patterns make it very easier to write unit tests and mock objects. By creating a factory interface, we can simply create mock or test-specific implementations to facilitate testing without affecting the rest of our code.</li>
        <li><strong>Encapsulation of Object Creation:</strong> Abstract Factory pattern encapsulates the creation of objects. This means that the client code does not need to be aware of the specific classes it is instantiating, promoting loose coupling between the client and the concrete objects.</li>
        </ul>
        <p dir="auto">Cons:</p>
        <ul dir="auto">
        <li><strong>Tight Coupling:</strong> Suppose if we needs to add new products or make changes to existing ones, than we need to modify both the abstract factory interface and the concrete factory implementations. This can lead to tight coupling between the factories and their products, potentially violating the Open-Closed Principle.</li>
        <li><strong>Increased Complexity:</strong> We need to define interfaces for factories and their product families, create concrete factory implementations, and manage the relationships between factories and products.</li>
        <li><strong>Code Duplication:</strong> While implementing concrete factories patterns for different product families, we end up with duplicate code for creating similar types of objects across multiple factories.</li>
        <li><strong>Reduced Runtime Flexibility:</strong> Once we choose a concrete factory to create objects, it is typically challenging to switch to a different factory at runtime. This limitation can restrict your ability to adapt to changing requirements dynamically.</li>
        <li><strong>Limited Use Cases:</strong> Abstract Factory pattern is most valuable in scenarios where there are multiple related product families with interchangeable components. In simpler applications, the overhead of implementing and maintaining factories may not be justified.</li>
        </ul>
      </article>
    </details>
    <script src="src/index.ts"></script>
  </body>
</html>
