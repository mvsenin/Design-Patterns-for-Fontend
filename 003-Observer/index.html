<!DOCTYPE html>
<html>
    <head>
        <title>Observer design pattern demo</title>
        <meta charset="UTF-8" />
        <link rel="stylesheet" href="./src/styles.css" />
    </head>

    <body>
        <div class="global-state">
            <label for="sensorValue">Sensor value: </label>
            <input id="sensorValue" name="sensorValue" value="0"/>
            <p>
            <button id="set-sensor-value">Set sensor value</button>
            | <button id="reset-sensor-value">Reset sensor</button>
            | <button id="add-monitor">Add observer</button>
            | <button id="notify-odd">Notify odd observers</button>
            | <button id="notify-even">Notify even observers</button>
            </p>
            Monitors' data:
            <span id="monitors-data" class="italic flex">No monitor exists</span>
        </div>
        <details class="container-lg">
            <summary>
              <b><img src="/src/hand-index-thumb.svg" height="30vh"/>Observer design pattern summary</b>
            </summary>
            <article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto">This is demo project for <strong>Observer design pattern</strong></p>
                <p dir="auto">This is one of the <strong>Behavioral design patterns</strong> which provide a way of decoupling the presentation from the business logic by isolating the behavior into its own class. This way, we can change the implementation without affecting any other part of our application.</p>
                <p dir="auto">There are several behavioral design patterns deal with separating our code into smaller, more manageable chunks.</p>
                <p dir="auto">Pros:</p>
                <ul dir="auto">
                <li><strong>Enhanced Decoupling:</strong> The Observer pattern fosters a desirable level of separation between components in a software system. It allows the subject to communicate changes to multiple observers without these entities being tightly bound to one another. As a result, changes made to one component do not necessitate extensive modifications in others, contributing to a more modular and maintainable codebase.</li>
                <li><strong>Reusability Across Subjects:</strong> Observers are designed to be reusable. This reusability is particularly advantageous when various subjects within an application require similar notification mechanisms. It promotes code reuse, reducing redundancy in your code.</li>
                <li><strong>Facilitation of Event-Driven Programming:</strong> The natural event-driven nature of the Observer pattern is a major asset. It aligns well with scenarios where you need to respond to events or changes as they occur, especially in environments that involve user interactions, such as web applications. This event-driven approach simplifies handling asynchronous operations.</li>
                <li><strong>Dynamic Adaptability:</strong> The Observer pattern allows for dynamic addition and removal of observers from a subject. This dynamic adaptability is invaluable when your application's requirements evolve over time. You can accommodate these changes without having to rewrite substantial portions of your codebase.</li>
                <li><strong>Ease of Testing:</strong> Observers can be tested independently, thanks to their decoupled nature. This lends itself well to unit testing practices, as you can create mock observers to simulate different scenarios and validate individual components.</li>
                <li><strong>Scalability Support:</strong> The Observer pattern is well-suited for scenarios that involve scaling the number of observers on the fly. It can efficiently manage a substantial volume of observers without compromising performance.</li>
                </ul>
                <p dir="auto">Cons:</p>
                <ul dir="auto">
                <li><strong>Complexity Concerns:</strong> Although the Observer pattern promotes decoupling, it's crucial to exercise caution regarding its use. Excessive application of the pattern can introduce complexity and intricacy into the codebase. Managing numerous observers and their interactions can become challenging, leading to less maintainable code.</li>
                <li><strong>Memory Management Responsibility:</strong> Proper memory management is paramount in the Observer pattern. Neglecting to remove observers when they are no longer necessary can result in memory leaks, a subtle but significant issue. Developers must be meticulous in managing observer subscriptions and unsubscriptions.</li>
                <li><strong>Performance Overhead:</strong> In situations where there is a substantial number of observers, the notification process can introduce performance overhead. Iterating through all observers and invoking their update methods can impact the application's real-time performance. Thus, developers need to be mindful of performance considerations, especially in time-sensitive systems.</li>
                <li><strong>Potential for Event Cascades:</strong> The Observer pattern's cascade effect is a potential challenge. When one observer's update method triggers changes in other observers, it can lead to a cascade of events, making the system harder to predict and debug.</li>
                <li><strong>Asynchronous Event Coordination:</strong> Coordinating the timing of updates between observers in asynchronous event scenarios can become intricate. Ensuring that observers handle events in a synchronized manner requires careful design and consideration.</li>
                <li><strong>Order of Notification Complexity:</strong> In some scenarios, the order in which observers are notified may be significant. Managing the order of notification can add another layer of complexity to the implementation, as it becomes necessary to specify and maintain a specific notification sequence.</li>
                </ul>
            </article>
        </details>
        <script src="src/index.ts"></script>
    </body>
</html>