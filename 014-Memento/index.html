<!DOCTYPE html>
<html>
  <head>
    <title>Command design pattern demo</title>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="./src/styles.css" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  </head>

  <body>
    <div class="global-state">
        <div class="global-state-row">
          <div class="global-state-col">
            <span class="title">Document Editor</span>
              <textarea id="editor" maxlength="100" placeholder="Please start typing text here..."></textarea>
            </span>
            <i>* max. 100 characters</i>
          </div>
          <div class="global-state-col">
            <span class="title">Editing history</span>
            <span>
              <button id="push">keep document version</button>
              <button id="undo" disabled="true">undo</button>
              <button id="redo" disabled="true">redo</button>
            </span>
            <span id="clipboard"></span>
            <i>* next version is added on top of the history</i>
          </div>  
        </div>
    </div>
    <details class="container-lg">
      <summary>
        <b><img src="/src/hand-index-thumb.svg" class="hand"/>Memento design pattern summary</b>
      </summary>
      <article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto">This is demo project for <strong>Memento design pattern</strong></p>
        <p dir="auto">This is one of the <strong>Behavioral design patterns</strong> which is focused on externalizing and capturing an object’s internal state so that it can later be restored. When you need to add features like undo/redo functionality, history tracking, or reverting an item to a former state, this pattern is quite helpful.</p>
        <p dir="auto">Pros:</p>
        <ul dir="auto">
        <li><strong>State Management:</strong> The primary advantage of the Memento pattern is its ability to manage an object’s state effectively. It allows you to capture and externalize an object’s internal state without exposing its implementation details.</li>
        <li><strong>Undo/Redo Functionality:</strong> The Memento pattern is well-suited for implementing undo and redo functionality in applications. Users can easily navigate through the history of an object’s states, providing a better user experience.</li>
        <li><strong>Maintains Encapsulation:</strong> The pattern enforces encapsulation by ensuring that only the Originator (the object whose state is being managed) has access to the Memento’s internal state. This helps maintain the integrity of the object’s data.</li>
        <li><strong>Flexibility:</strong> The Memento pattern is flexible and can be applied to various scenarios where you need to track and restore object states. It’s not limited to specific types of objects or use cases.</li>
        <li><strong>Versioning:</strong> It can be used to create version control systems where you track and restore the state of objects over time. This is valuable in collaborative applications and content management systems.</li>
        </ul>
        <p dir="auto">Cons:</p>
        <ul dir="auto">
        <li><strong>Memory Usage:</strong> Storing multiple Mementos in memory can consume a significant amount of memory, especially if you have a large number of objects with complex states. This can be a concern in resource-constrained environments.</li>
        <li><strong>Performance Overhead:</strong> The process of creating, storing, and managing Mementos can introduce some performance overhead, particularly when dealing with large objects or frequent state changes.</li>
        <li><strong>Complexity:</strong> Implementing the Memento pattern can introduce additional complexity to your code, especially if you need to manage the history of multiple objects or if you want to implement more advanced features like branching and merging states</li>
        <li><strong>Potential for Data Leakage:</strong> If not implemented correctly, there’s a risk of data leakage where external objects gain access to the internal state of Mementos, violating encapsulation.</li>
        <li><strong>behavioural:</strong> In languages without built-in support for object serialization and deep cloning, implementing Mementos and restoring object states can be more challenging and error-prone.</li>
        </ul>
      </article>
    </details>
    <script src="src/index.ts"></script>
  </body>
</html>
